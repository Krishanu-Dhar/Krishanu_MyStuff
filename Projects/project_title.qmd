---
title: "Analysis of DNA Replication Tracks"
date: 2025-07-26
author: Krishanu Dhar
editor_options: 
  chunk_output_type: console
---

## Description

This quarto document summarizes and analyzes **DNA replication track** data outputted from a Snakemake Pipeline \[[Link](https://github.com/SansamLab-Pipelines-Genomics/ReplisomeTracer)\]. Here, I will *filter and tidy the data*, then *plot it* out independently, as well as comparitively. Further I will try to *predict labeling states* within each sample. If the model doesn't look as robust as I expected, I will *use my own algorithm to predict the states*.

### About the Data

There are a couple of things that we should know about the data that we are going to use for the upcoming analyses.

-   First, we have bedfiles, which consist of *read IDs and their metadata*. These read IDs are unique, because these have DNA replication footprints. These footprints actually look pretty colorful (will see them in just a few moments). To better understand, here is snap of the workflow:

    ![](/projects/pictures/Workflow_Rep.png){width="55.6cm"}

    ### Loading the packages

    ```{r}
    #| echo: true
    #| message: false
    #| warning: false
    library(here)
    library(tidyverse)
    library(cowplot)
    library(zoo)
    cat("Working from:", here::here(), "\n")
    ```

    Let's have a glimpse at one of the bedfiles I mentioned above:

    ```{r}
    #| message: false
    #| warning: false

    try_bed <- read_table(
      here("projects", "data", "bedfiles", "NT", "leftForks_DNAscent_forkSense.bed"),
      comment = "#",
      col_names = FALSE
    )

    options(readr.show_col_types = FALSE)
    # Quick look
    glimpse(try_bed)

    # Assign proper column names
    colnames(try_bed) <- c(
      "chrom", "fork_start", "fork_end", "read_id",
      "read_start", "read_end", "strand",
      "fork_length", "score"
    )

    glimpse(try_bed)
    ```

-   Second, we have multiple bedgraph files. Each read ID is associated with two bedgraph files (one for EdU and one for BrdU). Let's look at a pair of bedgraphs for a read ID.

    ```{r}
    #| echo: true
    brdu_bed <- read_tsv(
      here("projects", "data", "bedgraphs", "NT", "BrdU__0b9d33df-6203-4c55-9ac5-c20ce628dde9.bedgraph")
    )
    edu_bed <- read_tsv(
      here("projects", "data", "bedgraphs", "NT", "EdU__0b9d33df-6203-4c55-9ac5-c20ce628dde9.bedgraph")
    )

    # Assigning column names
    colnames(edu_bed) <- c("chrom", "start", "end", "prob_score")
    colnames(brdu_bed) <- c("chrom", "start", "end", "prob_score")
    head(brdu_bed)
    head(edu_bed)
    ```

You might have guessed it from this. These bedgraphs hold information for the probability score of EdU/BrdU (thymidine analogs) across the entire read for every 100 base pairs (bin size).

## 

## Workflow

1.  Organize and tidy the data for better clarity.

2.  Plot the data

3.  Try predicting the labeling states within each sample, and find out their transition points

### [Organizing and tidying our data]{.underline}

```{r}
# ===Non-treated Sample (NT)===
left_df <- read_table(
  here("projects", "data", "bedfiles", "NT", "leftForks_DNAscent_forkSense.bed"),
  comment = "#",
  col_names = FALSE
)
right_df <- read_table(
  here("projects", "data", "bedfiles", "NT", "rightForks_DNAscent_forkSense.bed"),
  comment = "#",
  col_names = FALSE
)
origin_df <- read_table(
  here("projects", "data", "bedfiles", "NT", "origins_DNAscent_forkSense.bed"),
  comment = "#",
  col_names = FALSE
)
termination_df <- read_table(
  here("projects", "data", "bedfiles", "NT", "terminations_DNAscent_forkSense.bed"),
  comment = "#",
  col_names = FALSE
)
# Set column names (Origins and Terminations have different structure)
colnames(left_df) <- colnames(right_df) <- c(
  "chrom", "fork_start", "fork_end", "read_id",
  "read_start", "read_end", "strand",
  "fork_length", "score"
)
colnames(origin_df) <- colnames(termination_df) <- c("chrom", "fork_start", "fork_end", "read_id", "read_start", "read_end", "strand")

# Merge left and right forks
merged_df <- rbind(left_df, right_df)

# Extract read IDs
merged_ids <- unique(trimws(as.character(merged_df$read_id)))
exclude_ids <- unique(trimws(as.character(c(origin_df$read_id, termination_df$read_id))))

# Filter out excluded read IDs
filtered_ids <- setdiff(merged_ids, exclude_ids)

filtered_df_NT <- merged_df |>
  filter(read_id %in% filtered_ids)

# Optional: Exclude reads with score == -3
filtered_df_NT <- filtered_df_NT |> 
  filter(score != -3.000000)

# ===Treated sample (Auxin)===

left_df <- read_table(
  here("projects", "data", "bedfiles", "Auxin", "leftForks_DNAscent_forkSense.bed"),
  comment = "#",
  col_names = FALSE
)
right_df <- read_table(
  here("projects", "data", "bedfiles", "Auxin", "rightForks_DNAscent_forkSense.bed"),
  comment = "#",
  col_names = FALSE
)
origin_df <- read_table(
  here("projects", "data", "bedfiles", "Auxin", "origins_DNAscent_forkSense.bed"),
  comment = "#",
  col_names = FALSE
)
termination_df <- read_table(
  here("projects", "data", "bedfiles", "Auxin", "terminations_DNAscent_forkSense.bed"),
  comment = "#",
  col_names = FALSE
)
# Set column names (Origins and Terminations have different structure)
colnames(left_df) <- colnames(right_df) <- c(
  "chrom", "fork_start", "fork_end", "read_id",
  "read_start", "read_end", "strand",
  "fork_length", "score"
)
colnames(origin_df) <- colnames(termination_df) <- c("chrom", "fork_start", "fork_end", "read_id", "read_start", "read_end", "strand")

# Merge left and right forks
merged_df <- rbind(left_df, right_df)

# Extract read IDs
merged_ids <- unique(trimws(as.character(merged_df$read_id)))
exclude_ids <- unique(trimws(as.character(c(origin_df$read_id, termination_df$read_id))))

# Filter out excluded read IDs
filtered_ids <- setdiff(merged_ids, exclude_ids)

filtered_df_Aux <- merged_df |>
  filter(read_id %in% filtered_ids)

# Optional: Exclude reads with score == -3
filtered_df_Aux <- filtered_df_Aux |> 
  filter(score != -3.000000)

filtered_df_NT <- as.data.frame(filtered_df_NT)
filtered_df_Aux <- as.data.frame(filtered_df_Aux)

# Viewing the filtered dataframes
glimpse(filtered_df_NT)
glimpse(filtered_df_Aux)
# Saving the filtered bedfiles for future use
write_tsv(filtered_df_NT, 
            here("projects", "data","bedfiles", "NT", "final_filtered.bed"))
write_tsv(filtered_df_Aux, 
            here("projects", "data","bedfiles", "Auxin", "final_filtered.bed"))

```

### Plotting the Data

We are going to now see how the '.bedgraph' files look. I am going to first make an aggregate plot of them (one for each of the samples).

To start, we will need the help of a few user-defined functions. We will call them helper functions. These functions will have multiple input parameters, and at the same time they will return somethings as they are called..

```{r}

read_bedgraph_tracks <- function(directory) {
  filenames <- list.files(path = directory, pattern = ".bedgraph")
  dataframes <- lapply(file.path(directory, filenames), read.table)
  names(dataframes) <- filenames
  basenames <- gsub(".*__", "", filenames)

  brdu_edu_df_list <- lapply(basenames, function(base) {
    brdu <- dataframes[[paste0("BrdU__", base)]]
    edu  <- dataframes[[paste0("EdU__",  base)]]
    df <- data.frame(
      brdu[, 1:3],
      BrdU = brdu[, 4],
      EdU  = edu[, 4],
      diff = brdu[, 4] - edu[, 4],
      id = base
    )
    colnames(df) <- c("chromosome", "start", "end", "BrdU", "EdU", "diff", "read_ID")
    return(df)
  })

  return(brdu_edu_df_list)
}

align_diff_by_minimum <- function(df, window_size = 500) {
  df$diff_roll <- zoo::rollmean(df$diff, k = window_size, fill = NA, align = "center")
  min_start <- df$start[which.min(df$diff_roll)]
  max_start <- df$start[which.max(df$diff_roll)]
  if (min_start > max_start) df$start <- rev(df$start)
  min_start <- df$start[which.min(df$diff_roll)]
  df$x <- df$start - min_start
  return(df)
}

summarize_combined_tracks <- function(combined_df) {
  combined_df |>
    group_by(x) |>
    summarise(
      median_diff = median(diff, na.rm = TRUE),
      mean        = mean(diff,   na.rm = TRUE),
      sd          = sd(diff,     na.rm = TRUE),
      n           = sum(!is.na(diff)),
      se          = sd / sqrt(n),
      ci_lower    = mean - 1.96 * se,
      ci_upper    = mean + 1.96 * se,
      .groups     = "drop"
    )
}

detect_signal_boundaries <- function(summary_df) {
  roll_medians <- zoo::rollmedian(summary_df$median_diff, k = 151, align = "left", na.pad = TRUE)

  edu_start_idx <- which(roll_medians <= -0.1 & summary_df$x > -20000)
  edu_start     <- if (length(edu_start_idx) > 0) summary_df$x[min(edu_start_idx)] else NA

  brdu_start <- NA
  if (!is.na(edu_start)) {
    idx_range     <- which(summary_df$x > 0)
    above_zero    <- idx_range[roll_medians[idx_range] > 0]
    if (length(above_zero) > 0) brdu_start <- summary_df$x[above_zero[1]]
  }

  brdu_end <- NA
  if (!is.na(brdu_start)) {
    brdu_max_idx <- which.max(summary_df$x)
    later_range  <- which(summary_df$x > brdu_max_idx)
    below_thresh <- later_range[roll_medians[later_range] <= 0.5]
    if (length(below_thresh) > 0) brdu_end <- summary_df$x[below_thresh[1]]
  }

  summary_df$edu_start   <- edu_start
  summary_df$brdu_start  <- brdu_start
  summary_df$brdu_end    <- brdu_end
  return(summary_df)
}

make_aggregate_plot_df <- function(bedgraph_directory, sample_name) {
  replication_tracks <- read_bedgraph_tracks(bedgraph_directory)
  aligned            <- lapply(replication_tracks, align_diff_by_minimum)
  aligned_named      <- lapply(seq_along(aligned), function(i) {
    df <- aligned[[i]]
    df$id <- i
    df
  })

  combined_df <- do.call(rbind, aligned_named)
  summary_df  <- summarize_combined_tracks(combined_df)
  summary_df  <- summary_df[summary_df$x >= -40000 & summary_df$x <= 60000, ]
  summary_df$sample_name <- sample_name
  summary_df  <- detect_signal_boundaries(summary_df)
  return(summary_df)
}

```

```{r}
#| eval: false
#| include: false



# Setting the directory where our input data is
data_dir <- here("projects", "data/bedgraphs/Auxin")

sample_name <- "Auxin"
summary_df <- make_aggregate_plot_df(data_dir, sample_name)
boundaries <- summary_df[1, c("edu_start", "brdu_start", "brdu_end")]

summary_df |> 
  ggplot(aes(x = x, y = median_diff)) +
  geom_smooth(method = "loess", span = 0.2, se = TRUE, color = "lightblue") +
  geom_vline(xintercept = boundaries$edu_start,  linetype = "dashed", color = "purple", show.legend = TRUE) +
  geom_vline(xintercept = boundaries$brdu_start, linetype = "dashed", color = "darkgreen") +
  geom_vline(xintercept = boundaries$brdu_end,   linetype = "dashed", color = "darkred") +
  labs(title = "Aggregate BrdU - EdU signal", x = "Relative Position (bp)", y = "Median Δ signal (BrdU-EdU)", color = "boundaries") +
  annotate("text", x = boundaries$edu_start,  y = 0.5, label = round(boundaries$edu_start), color = "purple", angle = 45, vjust = -0.5) +
  annotate("text", x = boundaries$brdu_start, y = 0.5, label = round(boundaries$brdu_start), color = "darkgreen",  angle = 45, vjust = -0.5) +
  annotate("text", x = boundaries$brdu_end,   y = 0.5, label = round(boundaries$brdu_end), color = "darkred",    angle = 45, vjust = -0.5) +
  theme_cowplot()

```

```{r}
data_dir <- here("projects", "data/bedgraphs")

# List your sample names
sample_names <- c("NT", "Auxin")

# Load and annotate each sample's data
summary_all <- map_dfr(sample_names, function(sample_name) {
  df <- make_aggregate_plot_df(file.path(data_dir, sample_name), sample_name)
  df$sample_name <- factor(sample_name, levels = sample_names)
  
  # Also add the boundaries as columns (repeated per row)
  boundaries <- df[1, c("edu_start", "brdu_start", "brdu_end")]
  df$edu_start <- boundaries$edu_start
  df$brdu_start <- boundaries$brdu_start
  df$brdu_end <- boundaries$brdu_end
  
  return(df)
})

# Plot with facet wrap
summary_all |>
  ggplot(aes(x = x, y = median_diff)) +
  geom_line(color = "blue") +
  #geom_smooth(method = "loess", span = 0.2, se = TRUE, color = "lightblue") +
  geom_vline(aes(xintercept = edu_start), linetype = "dashed", color = "purple") +
  geom_vline(aes(xintercept = brdu_start), linetype = "dashed", color = "darkgreen") +
  geom_vline(aes(xintercept = brdu_end), linetype = "dashed", color = "darkred") +
  geom_text(aes(x = edu_start, y = 0.5, label = round(edu_start)), angle = 45, vjust = -0.5, color = "purple") +
  geom_text(aes(x = brdu_start, y = 0.5, label = round(brdu_start)), angle = 45, vjust = -0.5, color = "darkgreen") +
  geom_text(aes(x = brdu_end, y = -0.5, label = round(brdu_end)), angle = 45, vjust = -0.5, color = "darkred") +
  labs(title = "Aggregate BrdU - EdU signal", x = "Relative Position (bp)", y = "Median Δ signal (BrdU-EdU)") +
  facet_grid(sample_name ~.) +
  theme_cowplot()
```

Now, I want to have the data of each track.

```{r}
plot_each_track <- function(bedgraph_dir, sample_names){
  paired_tracks
}
```
